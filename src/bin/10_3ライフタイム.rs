fn main() {
    // ライフタイムとは、その参照が有効になるスコープのことです。
    // ライフタイムは、型が欲しい振る舞いを持つことを保証するのではなく、必要な間だけ参照が有効であることを保証するジェネリクスです。
    // 多くの場合、型が推論されるように、 大体の場合、ライフタイムも暗黙的に推論されます。
    // 参照のライフタイムがいくつか異なる方法で関係することがある場合には注釈しなければなりません。

    // &i32        (ただの)参照
    // &'a i32     明示的なライフタイム付きの参照
    // &'a mut i32 明示的なライフタイム付きの可変参照


    //ライフタイムでダングリング参照を回避する
        
        //ダングリング参照の例
    let r; //値が未定義の変数
        // 参照しようとするとコンパイルエラーになる
    {
        let x = 5;
        r = &x; //rが値の参照を得たので、このスコープ内でならrを参照できる
    }//ここでｘがドロップされるのでrの値が未定義に戻る
    // println!("r: {}", r); このコードでエラーになる

        //借用チェッカーのイメージ
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  | 
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    // println!("r: {}", r);          |
                          // ---------+
    // 'aは'bを参照するのに、'bは'aほど長生きしないことがわかる
    // コンパイラはこのように参照の対象が参照ほど長生きしないことを検知してプログラムを拒否する

        //修正例
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |  
    println!("r: {}", r); //   |       |
                          // --+       |
                          // ----------+
    // 参照の対象が参照よりも長生き
    println!("\n=======================");


    // 関数のジェネリックなライフタイム
    fn compare_len <'a>(x: &'a str, y: &'a str ) -> &'a str{ //返される参照は、両引数が有効である限り、有効(戻り値はより短命な方の参照引数に合わせる)
        if x.len() > y.len() {
            x
        }else {
            y
        }
    }
        // ライフタイム注釈は、シグニチャ内の型がそうであるように、その関数の契約の一部を構成する
        //ライフタイムの中でも引数のものは入力ライフタイム、戻り値のものは出力ライフタイムと呼ばれる

    let s1 = String::from("abcd");
    let s2 = "xyz";

    println!("大きい方は{}", compare_len(s1.as_str(), s2));
    println!("\n=======================");


    //異なるライフタイムを持つ参照の扱い
    let s3 = String::from("abcd");//こちらの方が長生き

    {
        let s4 = String::from("xyz");
        // let result = compare2(s3.as_str(), s4.as_str());
        // println!("今回大きい方は{}", result);
    }
    // 解決策として、
    // 関数シグネチャ内で長生きする方の引数と戻り値型だけにライフタイムを注釈するか、
    // 戻り値を参照されたデータではなく、所有権を持つデータにすることなどが挙げられる


    // 構造体定義のライフタイム注釈
        // 参照を保持する構造体の場合、該当データにライフタイム注釈が必要
    struct ImportantExcerpt<'a> {
        part: &'a str, //インスタンスは参照よりも短命であることを示す
    }

    let novel = String::from("昔々、あるところに");
    let first_sentence = novel.split('、').next().expect("Could not find a '、'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };


    //ライフタイムの省略
        //Rustチームはいくつかの決まりきったパターンでは注釈を省くべきだと考えた
        //そうしたパターンは三つあり、これらはライフタイム省略（個人的には推論）規則と呼ばれる
        //コンパイラは三つの規則を順番に適用してもライフタイムを推論できない場合のみ、注釈を要求する
    
    //三つの省略規則
        //1. 参照である各引数に、ライフタイムが割り当てられる
        //2. 一つだけ入力ライフタイムがあるなら、そのライフタイムがすべての出力ライフタイムに代入される
        //3. 複数の入力ライフタイム引数があるけれども、メソッドなのでそのうちの一つが&selfや&mut selfだったら、 selfのライフタイムが全出力ライフタイム引数に代入される

        //つまり、注釈が要求される一般的なケースとは、以下に当てはまるケースであると考えられる
            //参照を持つ引数が複数あり、
            //かつ、自己参照（&selfなど）がない

    
    //メソッドシグネチャにおける注釈
    impl <'a> ImportantExcerpt<'a> { //implキーワードと構造体名の後に注釈をつける必要がある
        //selfは一つ目の省略規則の適用外なので入力ライフタイムが不要
        //また、三番目の規則により、戻り値の注釈も不要
        fn level(&self) -> i32 { 
            3
        }
    }


    //静的ライフタイム
        //影響を受ける参照がプログラムの全期間生存できる特殊なライフタイム
        //'staticと記述する
    let s: &'static str = "静的ライフタイム";

        //文字列リテラルは全て静的ライフタイムが指定されている

    

    //ジェネリクスを適切に使用した関数（これまでのおさらい）
    use std::fmt::Display;

    fn _dongest_with_an_announcement<'a, T>(
        x: &'a str,
        y: &'a str,
        ann: T, 
    ) -> &'a str
    where
        T: Display, //println!マクロで{}により出力できるようにする
    {
        println!("アナウンス！ {}", ann);
        if x.len() > y.len() {
            x
        }else {
            y
        }
    }
}