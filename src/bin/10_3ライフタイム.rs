fn main() {
    // ライフタイムとは、その参照が有効になるスコープのことです。
    // ライフタイムは、型が欲しい振る舞いを持つことを保証するのではなく、必要な間だけ参照が有効であることを保証するジェネリクスです。
    // 多くの場合、型が推論されるように、 大体の場合、ライフタイムも暗黙的に推論されます。
    // 参照のライフタイムがいくつか異なる方法で関係することがある場合には注釈しなければなりません。


    //ライフタイムでダングリング参照を回避する
        
        //ダングリング参照の例
    let r; //値が未定義の変数
        // 参照しようとするとコンパイルエラーになる
    {
        let x = 5;
        r = &x; //rが値の参照を得たので、このスコープ内でならrを参照できる
    }//ここでｘがドロップされるのでrの値が未定義に戻る
    // println!("r: {}", r); このコードでエラーになる

        //借用チェッカーのイメージ
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  | 
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    // println!("r: {}", r);          |
                          // ---------+
    // 'aは'bを参照するのに、'bは'aほど長生きしないことがわかる
    // コンパイラはこのように参照の対象が参照ほど長生きしないことを検知してプログラムを拒否する

        //修正例
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |  
    println!("r: {}", r); //   |       |
                          // --+       |
                          // ----------+
    // 参照の対象が参照よりも長生き
    println!("\n=======================");


    // 関数のジェネリックなライフタイム
    use std::cmp::PartialOrd;
    fn compare_len<T: PartialOrd>(x: &T, y: &T ) -> &T{
        if &x > &y {
            &x
        }else {
            &y
        }
    }

    let s1 = String::from("abcd");
    let s2 = "xyz";

    compare_len(&s1, &s2)

}